---
title: "Orebro RNA-seq analysis"
author: "Rodrigo Arcoverde Cerveira & Gustav Joas"
date: '`r format(Sys.Date(), "%Y-%m-%d")`'
output: html_document
abstract: Örebro study RNA-seq data analysis.
knit: (function(inputFile, encoding) {
          rmarkdown::render(inputFile,
                            encoding = encoding, 
                            output_file = paste0(
                              xfun::sans_ext(inputFile), '_', Sys.Date(), '.html'),
                                output_dir = "../results/lab_book/")})
editor_options: 
  chunk_output_type: inline
---

```{r global.options, include=FALSE}
#setting up figures and chunks messages

knitr::opts_knit$set(echo = TRUE,
                     root.dir = getwd(),
                     fig.width = 6, fig.height = 5,
                     fig.align = "center",
                     out.width = 768,
                     fig.pos = "H",
                     warning = FALSE, 
                     message = FALSE)
knitr::opts_chunk$set(warning = FALSE,
                      message = FALSE,
                      fig.width = 6, fig.height = 5,
                     fig.align = "center",
                     out.width = 768,
                     fig.pos = "H")

result.dir <- paste0("results/",Sys.Date(),"/")
figures.dir <- paste0("results/",Sys.Date(),"/", "figures/")
## creates result.dir with date in if not existent
ifelse(isFALSE(dir.exists(paste0("../",result.dir))), dir.create(paste0("../",result.dir),recursive = TRUE),"Result directory for today exists already!")
ifelse(isFALSE(dir.exists(paste0("../",figures.dir))), dir.create(paste0("../",figures.dir),recursive = TRUE),"Result directory for today exists already!")

options(stringsAsFactors = FALSE) 
```

## Loading libraries

```{r, message=FALSE}
#if you do not have libraries, they are located in either CRAN or Bioconductor
library(data.table)
library(kableExtra)
library(forcats)
library(caret)
library(C50)
library(mgsub)
library(DESeq2) 
library(pheatmap) 
library(ggplot2) 
library(ggrepel) 
library(RColorBrewer) 
library(limma) 
library(edgeR) 
library(enrichR) 
library(gridExtra) 
library(stringr)
library(ggVennDiagram)
library(dplyr) 
library(ensembldb)
library(EnsDb.Hsapiens.v86)
library(factoextra)
library(rafalib)
library(plotly)
library(tibble)
library(devtools)
library(clusterProfiler)
library(enrichplot)
library(pathview)

```


## Download and load data

```{r}
# Reading data
counts_raw <- data.table::fread("../data/proces-data_core-facility/subreadCounts_hg38ens_minus_frag.txt", header = TRUE, sep = "\t") %>%  as.data.frame()

sampleTable <- read.table("../data/metadata/sample_metadata.csv", sep = ",", header = TRUE) %>%
  mutate(dose = as.factor(plyr::mapvalues(visit, from = c(1,2,4,5), to = c("0_dose1","24_dose1","0_dose2","24_dose2"))),
         group = as.factor(group))

# Remove incomplete sample
sampleTable<-subset(sampleTable, sample_ID!="P22761_1037_S37")

# Renaming genes based on emsembl annotation
edb <- EnsDb.Hsapiens.v86
edb_genes <- genes(edb) %>% as.data.frame()

counts_raw <- counts_raw %>%
  dplyr::select(-c(Chr, Start, End, Strand, Length)) %>%
  dplyr::mutate(Geneid = plyr::mapvalues(x = counts_raw$Geneid, from = edb_genes$gene_id, to = edb_genes$symbol, warn_missing = FALSE))

# Aggregate and sum up genes with same gene symbol, which were basically non-coding RNAs
counts_raw <- aggregate(counts_raw[,-1], list(Geneid=counts_raw[,1]), FUN = sum)
rownames(counts_raw) <- counts_raw$Geneid
counts_raw <- dplyr::select(counts_raw, -c(Geneid))

# Read antibody data

antibody_data <- read.csv("../data/antibody_data/2022-04-26_antibody-binding-avidity.csv")

# Load BTM modules
gmt <- read.gmt("../data/blood_transcription_module/BTM_for_GSEA_20131008.gmt")

# Load normalized transcripts per million

```

## Basic Quality Control

### Inspect raw data

Matching metadata to countTable and plotting the raw counts for first visual inspection.

```{r}
# Synchronize count data with sample table
counts_raw <- counts_raw[, pmatch(sampleTable$sample_ID, colnames(counts_raw))]
colnames(counts_raw) <- sampleTable$sample_ID
all(rownames(sampleTable$sample_ID) == colnames(counts_raw))

# Visualize distribution of raw counts w/ boxplot and density plot
{
  pdf(paste0("../", figures.dir,"raw_counts_QC.pdf"), width = 10,  height = 8, compress = TRUE )
  rafalib::mypar(1,2,mar=c(10,3,3,2))
  boxplot(log2(as.matrix(counts_raw)+1),ylab=expression('Log'[2]~'Read counts'),las=2,main="Raw data")
  hist(log2(as.matrix(counts_raw)+1),ylab="",las=2,main="Raw data")
  par(mfrow=c(1,1))
  dev.off()
}
```

### Filter data

Plot detection of genes across samples. All samples are more or less close to average so we don't need to discard any samples.

```{r}
{
  pdf(paste0("../", figures.dir,"number_detected_genes.pdf"), width = 10,  height = 8, compress = TRUE )
  par(mar=c(10,4,3,4))
  barplot(colSums(counts_raw>3),ylab="Number of detected genes",las=2)
  abline(h=median(colSums(counts_raw>3)))
  dev.off()
}
```

Removing reads with the log2 of the counts per million (cpm) lower than 1.

```{r}

#Filter low counts
keep_genes <- rowSums( counts_raw > 5 ) >= 8
counts_filtered<- counts_raw[keep_genes,]
sum(keep_genes)


meanLog2CPM <- rowMeans(log2(cpm(counts_raw) + 1)) 
counts_filtered <- counts_raw[meanLog2CPM > 1, ] 


```

Plot detection rate across genes for raw and filtered counts

```{r}
{
  pdf(paste0("../", figures.dir,"detection_rate_raw_filtered.pdf"), width = 10,  height = 8, compress = TRUE )
  par(mar=c(10,4,3,4))
  hist(rowSums(counts_raw>3))
  hist(rowSums(counts_filtered>3))
  par(mfrow=c(1,1))
  dev.off()
}
```

Plot distribution of the filtered counts

```{r}
{
  pdf(paste0("../", figures.dir,"filtered_counts_distribution.pdf"), width = 10,  height = 8, compress = TRUE )
  rafalib::mypar(1,2,mar=c(10,3,3,2))
  boxplot(log2(as.matrix(counts_filtered)+1),ylab=expression('Log'[2]~'Read counts'),las=2,main="Filtered data")
  hist(log2(as.matrix(counts_filtered)+1),ylab="",las=2,main="Filtered data")
  par(mfrow=c(1,1))
  dev.off()
}
```

### DESeq object creation, Normalization and data Quality Control

Generating the DESeq dataset.

```{r}
# prepare for DESeq
sampleTable$conditions <- (str_c(sampleTable$group, "_", sampleTable$dose ))
sampleTable$conditions <- factor(sampleTable$conditions)
sampleTable$sex <- factor(sampleTable$sex)
sampleTable$dose <- factor(sampleTable$dose)
sampleTable$group <- factor(sampleTable$group)

sampleTable$time <- sampleTable$conditions  
sampleTable$time <- gsub('.{6}$', '', sampleTable$time)
sampleTable$time <- factor(sampleTable$time)
# create 3 DESeq object
dds1 <- DESeqDataSetFromMatrix(countData = counts_filtered,
                              colData = as.data.frame(sampleTable),
                              design = ~  sex + age + conditions)

dds2 <- DESeqDataSetFromMatrix(countData = counts_filtered,
                              colData = as.data.frame(sampleTable),
                              design = ~  sex + age + time)

dds3 <- DESeqDataSetFromMatrix(countData = counts_filtered,
                              colData = as.data.frame(sampleTable),
                              design = ~  sex + age + dose)
# Normalize with rlog
counts_rlog_normalized <- rlog(dds1, blind = TRUE)

# Normalize with variance stabilizing transformation for later PCA and heatmap
counts_vst_normalized <- vst(dds1, blind = TRUE)
```

Plot distribution of data after normalization

```{r}
# haven't decided which plots to use
vst_matrix <- assay(counts_vst_normalized) 
rlog_matrix <- assay(counts_rlog_normalized)
hist(vst_matrix)
hist(rlog_matrix)
boxplot(vst_matrix ,ylab=expression('Log'[2]~'Read counts'),las=2,main="VST")
boxplot(rlog_matrix ,ylab=expression('Log'[2]~'Read counts'),las=2,main="rlog")

```

### Heatmap

```{r}
# Sample heatmap
sampleDist <- cor(vst_matrix, method = "spearman") 

Metadata <- data.frame(sampleTable$group, sampleTable$dose)
names(Metadata) <- c("Group","Dose")
rownames(Metadata) <- sampleTable$sample_ID

# Plot heatmap
colors<-colorRampPalette(rev(brewer.pal(n=7,name="RdBu")))(255)

{
  pdf(paste0("../", figures.dir,"heatmap.pdf"), width = 10,  height = 8, compress = TRUE )
 Heatmap <-  pheatmap(sampleDist, 
           color = colors,
           clustering_distance_rows = as.dist(1 - sampleDist),
           clustering_distance_cols = as.dist(1 - sampleDist), 
           show_rownames = F,
           show_colnames = F,
           clustering_method = "ward.D2",
           annotation_col = Metadata)
  par(mfrow=c(1,1))
  dev.off()
}

print(Heatmap)
```

### Principal Component Analyais (PCA)

Dimensionality reduction for evaluating outliers and global sample clusters for both quality control but also for primary exploratory analysis.

```{r}
#Sample PCA
pcaRes <- prcomp(t(assay(counts_vst_normalized)))
varExp <- round(summary(pcaRes)[[1]],digits = 2)

pcaDF <- data.frame(
  PC1 = pcaRes$x[, 1],
  PC2 = pcaRes$x[, 2],
  Group = sampleTable$group,
    Sample = sampleTable$sample_ID,
  Dose = sampleTable$dose)

{ 
  pdf(paste0("../", figures.dir,"PCA.pdf"), width = 10,  height = 8, compress = TRUE )
  pcaPlot <- ggplot( pcaDF, mapping = aes(x = PC1, y = PC2, color = Group, label = Sample)) + 
  geom_point(aes(shape = Dose), size = 3) +
  labs(x = paste0("PC1 (", varExp[1], " %)"), y = paste0("PC2 (", varExp[2], " %)")) + 
  theme(axis.text = element_text(size = 12), legend.text = element_text(size = 10)) +
  scale_color_manual(values = brewer.pal(3, "Accent")) +
  cowplot::theme_cowplot()
  par(mfrow=c(1,1))
  dev.off()
}

print(pcaPlot)

## make a scree plot to compute PC variance
pca.var <- pcaRes$sdev^2
pca.var.per <- round(pca.var/sum(pca.var)*100, 1)
{
  pdf(paste0("../", figures.dir,"Scree_plot.pdf"), width = 10,  height = 8, compress = TRUE )  
  barplot(pca.var.per, main="Scree Plot", xlab="Principal Component", ylab="Percent Variation")
  par(mfrow=c(1,1))
  dev.off()
}
## exploring which variables contribute the most for each PC
var <- get_pca_var(pcaRes)
var$contrib %>%
  as.data.frame() %>%
  arrange(desc(Dim.1)) %>%
  head()
# many are related to sex, thus for the later analysis we should remove those and also normalize per sex the counts
  
```

## Differential Gene Expression Analysis

```{r}
# Run the DESeq2 analysis
dds1 <-  DESeq(dds1)
dds2 <-  DESeq(dds2)
dds3 <-  DESeq(dds3)

# contrast
resultsNames(dds1)
resultsNames(dds2)
resultsNames(dds3)

# Results dds1

# Baselines DEGs
res_baseline_pos_neg_dose1 <- as.data.frame(results(dds1, contrast = c("conditions", "Pos_0_dose1", "Neg_0_dose1")))
res_baseline_pos_neg_dose2 <- as.data.frame(results(dds1, contrast = c("conditions", "Pos_0_dose2", "Neg_0_dose2")))
res_baseline_pos_doses <- as.data.frame(results(dds1, contrast = c("conditions", "Pos_0_dose2", "Pos_0_dose1")))
res_baseline_neg_doses <- as.data.frame(results(dds1, contrast = c("conditions", "Neg_0_dose2", "Neg_0_dose1")))
#add vaseline for Pos vs neg regardless of dose (theres is a difference here), and then regardles of statu (not here)


# 0-24h Degs
res_neg_dose1 <- as.data.frame(results(dds1, contrast = c("conditions", "Neg_24_dose1", "Neg_0_dose1")))
res_pos_dose1 <- as.data.frame(results(dds1, contrast = c("conditions", "Pos_24_dose1", "Pos_0_dose1")))
res_neg_dose2 <- as.data.frame(results(dds1, contrast = c("conditions", "Neg_24_dose2", "Neg_0_dose2")))
res_pos_dose2 <- as.data.frame(results(dds1, contrast = c("conditions", "Pos_24_dose2", "Pos_0_dose2")))

# Results dds2
res_pos <- as.data.frame(results(dds2, contrast = c("time", "Pos_24", "Pos_0")))
res_neg <- as.data.frame(results(dds2, contrast = c("time", "Neg_24", "Neg_0")))

# Results dds3
res_dose1 <- as.data.frame(results(dds3, contrast = c("dose", "24_dose1", "0_dose1")))
res_dose2 <- as.data.frame(results(dds3, contrast = c("dose", "24_dose2", "0_dose2")))
```


### Volcano plots

Volcano plot for data exploratory analysis, filtering for significant values with False Discovery Rate \< 0.05 and log fold change greater than 1.

```{r}
# check only the negative fold change to see if there's a different pahtway of negative fold changes

results_list <- list(res_baseline_pos_neg_dose1, res_baseline_pos_neg_dose2, res_baseline_pos_doses, res_baseline_neg_doses, res_neg_dose1, res_pos_dose1, res_neg_dose2, res_pos_dose2, res_pos, res_neg, res_dose1, res_dose2)

names(results_list) <- c("Baseline Dose 1", "Baseline Dose 2", "Baseline Conv", "Baseline Naïve", "Naïve Dose 1", "Conv Dose 1", "Naïve Dose 2", "Conv Dose 2", "Conv","Naïve", "Dose 1", "Dose 2") 

results_list_plot <- lapply(results_list, function(x) {

  x <- x %>% mutate(test_padj = case_when(padj < 0.05 & log2FoldChange >= 1 ~ "Up regulated",
                                     padj < 0.05 & log2FoldChange <= -1 ~ "Down regulated",
                                     TRUE ~ "Not significant"),
                    test_padj = case_when(pvalue < 0.05 & log2FoldChange >= 1 ~ "Up regulated",
                                     padj < 0.05 & log2FoldChange <= -1 ~ "Down regulated",
                                     TRUE ~ "Not significant"),
                    )
  })
# color by group dose1 and dose2, or neg and pos. 2 plots colored based on condition
# color by group dose1 and dose2, or neg and pos. 2 plots colored based on condition
# function to plot and save volcano plot
.volcano_plot <-  function(x){
  subsetted <- subset(results_list_plot[[x]] %>% tibble::rownames_to_column("gene_symbol"), grepl("^IL1RN|^IL1B|^IL1A|^IL1R1|^IL1A|^NOD|^CASP1$|^GSDMD|^NLR|^TNFA$|^TNF$|TNFRSF1A|^IL6$|^IFNAR|PYCARD", gene_symbol) & abs(log2FoldChange) >= 1 & padj < 0.05) %>%
    mutate(gene_symbol == ifelse(grepl("DDX58", gene_symbol), "RIG-1",gene_symbol)) 
  
  # count up regulated DEGs
  deg_number_up <- subset(results_list_plot[[x]] %>% tibble::rownames_to_column("gene_symbol"), log2FoldChange >= 1 & pvalue < 0.05) %>%
    nrow()
  # count down regulated DEGs
  deg_number_down <- subset(results_list_plot[[x]] %>% tibble::rownames_to_column("gene_symbol"), log2FoldChange <= -1 & pvalue < 0.05) %>%
    nrow()
  
  results_list_plot[[x]] %>% 
  ggplot(aes(x=log2FoldChange,y=-log10(pvalue))) +
  geom_point(aes(colour=test_pvalue), size=3, alpha=0.3) +
  scale_color_manual(values = c("Down regulated"="blue", "Not significant" ="grey80", "Up regulated"="red")) +
  xlab(expression("Fold Change (Log"[2]*")")) +
  ylab(expression("-Log"[10]*"(p-value)")) +
  geom_vline(xintercept = c(-1, 1), linetype = "dotted", size = 1) + 
  geom_hline(yintercept = -log10(0.05), linetype = "dotted", size = 1) +
  geom_text_repel(data = subsetted, aes(log2FoldChange,-log10(pvalue),label= gene_symbol), max.overlaps = 5, size =7) +
  xlim(-2,6) +
  ylim(0,10) +
 # ggtitle(x) +  
  annotate(
        geom='text',
        colour = "red",
        size = 10,
        x= 4, y=10,
        hjust=0,
        label=paste0(deg_number_up)
    ) +
    annotate(
        geom='text',
        colour = "blue",
        size = 10,
        x= -2, y= 10,
        hjust=0,
        label=paste0(deg_number_down)
    ) +
  cowplot::theme_cowplot(font_size = 20, line_size = 1.5, rel_small = 1.6, rel_tiny = 1,font_family = "Arial",rel_large = 4) +
  theme(legend.position = 'none',
        axis.title = element_text(size = 35))
  }

volcano_plots <- lapply(names(results_list_plot), .volcano_plot)
names(volcano_plots) <- names(results_list_plot)
volcano_plots

  lapply(names(volcano_plots), function(x) ggsave(filename = paste0("../", figures.dir, x,"_volcano_plot.png"), width = 7, height = 7,
                                         plot = volcano_plots[[x]]))




```


```{r}

#MA plot
  
 #Counts plot
# plotCounts(d,gene=rownames(res)[1],intgroup="group",normalized=F)
# plotCounts(d,gene=rownames(res)[1],intgroup="group",normalized=T)
```

### Enrichment analysis

Selecting two different databases for search for enrichment analysis. The databases selected were "GO_Biological_Process_2021" and "KEGG_2021_Human". Testing also the Blood Transcriptome modules presented in [Li et al. 2014](10.1038/ni.2789) using some GSEA package.

```{r}
#Enrichment analysis
listEnrichrDbs()

enrichment_list_up <- lapply(results_list_plot, function(x) {
  enrichr(
  genes = rownames(x[x$test_padj == "Up regulated", ]),
  databases = c("GO_Biological_Process_2021", "KEGG_2021_Human","GO_Molecular_Function_2021"))})

enrichment_list_down <- lapply(results_list_plot, function(x) {
  enrichr(
  genes = rownames(x[x$test_padj == "Down regulated", ]),
  databases = c("GO_Biological_Process_2021", "KEGG_2021_Human","GO_Molecular_Function_2021"))})

```

#### Visualize enriched pathways

```{r echo=TRUE, fig.width=15, fig.height=8}

#Removing items without significant results from list
enrichment_list_up[c("neg_dose1")] <- NULL
enrichment_list_down[c("baseline", "neg_dose1", "pos_dose1", "neg", "dose1")] <- NULL

#Visualize significant terms
enrichment_list <- enrichment_list_up

plots_enrich <- list()
for(pathway in 1:length(enrichment_list_up[[1]])){
  
  rbinded_enrich_list <- lapply(enrichment_list, function(x)x[[pathway]])
  print(names(enrichment_list[[1]])[[pathway]])
  rbinded_enrich_df <- data.table::rbindlist(l = rbinded_enrich_list, idcol = TRUE, fill = TRUE)
  
  plots_enrich[[pathway]] <- rbinded_enrich_df %>%
  group_by(.id) %>%
  arrange(Adjusted.P.value) %>%
  slice(1:10) 
  
}

lapply(plots_enrich, function(x){
  x %>%
  ggplot(aes(x = Term, y = -log10(Adjusted.P.value))) +
    geom_bar(stat = "identity", width = 0.05) + geom_point(size = 3) +
    theme_minimal() +
    theme(text = element_text(size = 10),
          plot.title = element_text(hjust = (5 / nchar(results_list)) * 2), 
          plot.margin = margin(t = 5, r = 50, b = 5, unit = "pt"), 
          axis.text.y = element_text(size = 8)) +
    coord_flip() +
    geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "gray") + 
    theme_bw() +
    labs(y = expression("Adjusted P value, Log"[10]*"")) +
  facet_wrap(~.id)
})


```

### Gene Set Enrichment Analysis with ClusterProfiler

#### Annotaions

```{r, message=F, warning=F}
# SET THE DESIRED ORGANISM HERE
organism <- "org.Hs.eg.db"
# BiocManager::install(organism, character.only = TRUE)
library(organism, character.only = TRUE)
```

#### Prepare Input

```{r}
process_to_gsea <- function(x){
  original_gene_list <- x$log2FoldChange
  names(original_gene_list) <- rownames(x)
  gene_list<-na.omit(original_gene_list)
  gene_list <- sort(gene_list, decreasing = TRUE)
}

ls_processed <- lapply(results_list, process_to_gsea)

```

#### Gene Set Enrichment

```{r}
list_gse <- lapply(ls_processed, function(x) GSEA(geneList=x, 
            TERM2GENE = gmt,
             minGSSize = 3, 
             maxGSSize = 800, 
            nPermSimple = 10000,
             pvalueCutoff = 0.05, 
             verbose = TRUE, 
             pAdjustMethod = "fdr"))


```


#### Ridgeplot
Helpful to interpret up/down-regulated pathways.
```{r fig.width=18, fig.height=12}
# change coloring for up and downregulated
# try also to plot as a heatmap for all the group comparisons

rigdgeplots_list <- lapply(list_gse, ridgeplot, fill = "NES")
lapply(names(rigdgeplots_list), function(x) ggsave(filename = paste0("../", figures.dir, x,"_BTM_plot.pdf"), 
                                         plot = rigdgeplots_list[[x]], width = 15, height = 10))
rigdgeplots_list

```

#### Combined GSEA heatmap

```{r gsea_heatmap}
my_palette <- colorRampPalette(c("#265891", "white", "#B80F20"))(n = 20)
sel_list_gse <- list_gse[c("Naïve Dose 1","Conv Dose 1", "Naïve Dose 2","Conv Dose 2")]
combined_gsea <- data.table::rbindlist(lapply(sel_list_gse, as.data.frame), idcol = TRUE) %>%
  group_by(.id) %>% arrange(desc(NES)) %>% ungroup()

to_heatmap <- combined_gsea %>%
  select(.id,ID,NES) %>%
  filter(NES > 2 | NES < -2, !grepl("TBA", ID)) %>%
  tidyr::pivot_wider(values_from = NES, names_from = ID) %>%
  mutate(across(where(anyNA), ~ tidyr::replace_na(., 0))) %>%
  t()
colnames(to_heatmap) <- to_heatmap[1,] 
to_heatmap <- to_heatmap[-1,]


{pdf(paste0("../",result.dir, "heatmap_gsea.pdf"))
 matrix(as.numeric(to_heatmap),ncol = ncol(to_heatmap)) %>%
   pheatmap::pheatmap(cellwidth = 20, 
                      cellheight = 5,
                      cluster_rows = T, cluster_cols = T,
                      border_color = "black",cutree_cols = 4,
                      color = my_palette,
                      labels_col = colnames(to_heatmap),
                      labels_row = rownames(to_heatmap),treeheight_col = 1,fontsize_row = 6) 
 dev.off()
}

```


#### Dotplot
```{r echo=TRUE, fig.width=15, fig.height=8}
#require(DOSE)
#dotplot(gse, showCategory=10, split=".sign") + facet_grid(.~.sign)
```

#### GSEA Plot  
Traditional method for visualizing GSEA result.  
  
```{r fig.height=6, fig.width=8}
# Use the `Gene Set` param for the index in the title, and as the value for geneSetId
#gseaplot(gse, by = "all", title = gse$Description[55], geneSetID = 55)
#head(gse, 100)

```


### KEGG Gene Set Enrichment Analysis
#### Prepare Input
```{r}
# Convert gene IDs for gseKEGG function
# We will lose some genes here because not all IDs will be converted
ids<-bitr(names(ls_processed[[5]]), fromType = "SYMBOL", toType = "ENTREZID", OrgDb=organism)
# remove duplicate IDS (here I use "ENSEMBL", but it should be whatever was selected as keyType)
dedup_ids = ids[!duplicated(ids[c("SYMBOL")]),]
# Create a new dataframe df2 which has only the genes which were successfully mapped using the bitr function above
df2 = res_pos[rownames(res_pos) %in% dedup_ids$SYMBOL,]
# Create a new column in df2 with the corresponding ENTREZ IDs
df2$Y = dedup_ids$ENTREZID
# Create a vector of the gene unuiverse
kegg_gene_list <- df2$log2FoldChange
# Name vector with ENTREZ ids
names(kegg_gene_list) <- df2$Y
# omit any NA values 
kegg_gene_list<-na.omit(kegg_gene_list)
# sort the list in decreasing order (required for clusterProfiler)
kegg_gene_list = sort(kegg_gene_list, decreasing = TRUE)
```


#### Create gseKEGG object
 
```{r}
#kegg_organism = "hsa"
#kk2 <- gseKEGG(geneList     = kegg_gene_list,
#               organism     = kegg_organism,
#               nPerm        = 10000,
#               minGSSize    = 3,
#               maxGSSize    = 800,
#               pvalueCutoff = 0.05,
#               pAdjustMethod = "fdr",
#               keyType       = "ncbi-geneid")

```
#### Ridgeplot
Helpful to interpret up/down-regulated pathways.
```{r fig.width=18, fig.height=12}
#gseKEGG(kk2) + labs(x = "enrichment distribution")
```

### Pathview
This will create a PNG and *different* PDF of the enriched KEGG pathway.  
```{r, message=F, warning=F, echo = TRUE}
# Produce the native KEGG plot (PNG)
#dme <- pathview(gene.data=kegg_gene_list, pathway.id="hsa04620", species = kegg_organism)
# Produce a different plot (PDF) (not displayed here)
#dme <- pathview(gene.data=kegg_gene_list, pathway.id="map04620", species = kegg_organism, kegg.native = F)
```

```{r pressure, echo=TRUE, fig.cap="KEGG Native Enriched Pathway Plot", out.width = '100%'}
#knitr::include_graphics("hsa03015.pathview.png")
```

### Visualization of DEGS

#### Heatmap of DEGs

```{r heatmap_degs}
edb_gene_length <- edb_genes %>%
  mutate(gene_length = end - start) %>%
  select(symbol, gene_length)
counts_vst <- assay(vst(dds1, blind = FALSE))

rpkm_filtered <- rpkm(counts_vst, gene.length = edb_gene_length[edb_gene_length$symbol %in% rownames(counts_filtered),]$gene_length)

rpkm_filtered <- rpkm_filtered[, pmatch(sampleTable$sample_ID, colnames(rpkm_filtered))]
colnames(rpkm_filtered) <- sampleTable$sample_ID
all(rownames(sampleTable$sample_ID) == colnames(rpkm_filtered))

extract_degs_names <-  function(x){
  subsetted <- results_list_plot[[x]] %>% tibble::rownames_to_column("gene_symbol") %>%
    filter(log2FoldChange > 1 & padj < 0.05) %>%
    select(gene_symbol, log2FoldChange)
  return(subsetted)
}

colnames(rpkm_filtered) <- plyr::mapvalues(colnames(rpkm_filtered), from = sampleTable$sample_ID, to = paste(sampleTable$subject_ID, sampleTable$dose,sep="_"))

degs_names_list <- lapply(names(results_list_plot), extract_degs_names)
names(degs_names_list) <- names(results_list_plot)
degs_names <- unique(data.table::rbindlist(degs_names_list))[[1]]

sampleTable <- sampleTable %>% mutate(ID_time_dose = paste(subject_ID, dose, sep = "_"))
rownames(sampleTable) <- sampleTable$ID_time_dose

rpkm_filtered[degs_names,] %>% 
  pheatmap(color = colors,
           show_rownames = F,
           show_colnames = F,
           clustering_method = "ward.D2",
           annotation_col = sampleTable[8:9],
           scale = "row")

```

#### Venn Diagram of DEGs

```{r venn_diagram}
to_venn <- list(pos_dose1 = degs_names_list[[6]][[1]],
                neg_dose2 = degs_names_list[[7]][[1]], 
                pos_dose2 = degs_names_list[[8]][[1]])

ggVennDiagram(to_venn, label_alpha = 0, label_color = "black",
              category.names = c("Conv Dose 1","Naïve Dose 2","Conv Dose 2"), set_size = 7, edge_size = .5) +
  scale_x_continuous(expand = expansion(mult = .2)) +
  scale_fill_distiller(direction = -1) +
  scale_color_manual(values = c(rep("black", 3)))
 ggsave(paste0("../",result.dir,"venn_diagram.pdf"),
         width = 6,height = 5, dpi = 300)
 
intersect_degs <- Reduce(intersect, to_venn)
setdiff_degs_naive <- Reduce(setdiff, list(neg_dose2 = degs_names_list[[7]][[1]],degs_names_list[[8]][[1]], pos_dose1 = degs_names_list[[6]][[1]]))
setdiff_degs_conv <- Reduce(setdiff, list(degs_names_list[[8]][[1]], degs_names_list[[7]][[1]], degs_names_list[[6]][[1]]))


ORA_intersect <- enrichGO(
  gene = intersect_degs, ont = "BP", OrgDb = org.Hs.eg.db, keyType = "SYMBOL")
ORA_setdiff_degs_naive <- enrichGO(
  gene = setdiff_degs_naive, ont = "BP", OrgDb = org.Hs.eg.db, keyType = "SYMBOL")
ORA_setdiff_degs_conv <- enrichGO(
  gene = setdiff_degs_conv, ont = "BP", OrgDb = org.Hs.eg.db, keyType = "SYMBOL")

avg_FC <- (res_pos_dose1[intersect_degs,]$log2FoldChange + res_pos_dose2[intersect_degs,]$log2FoldChange + res_neg_dose2[intersect_degs,]$log2FoldChange)/3 
names(avg_FC) <- rownames(res_pos_dose1[intersect_degs,])

avg_FC_diff_naive <-  res_neg_dose2[setdiff_degs_naive,]$log2FoldChange 
names(avg_FC_diff_naive) <- rownames(res_pos_dose1[setdiff_degs_naive,])

avg_FC_diff_conv <-  res_pos_dose2[setdiff_degs_conv,]$log2FoldChange 
names(avg_FC_diff_conv) <- rownames(res_pos_dose2[setdiff_degs_conv,])

dotplot(ORA_intersect)
dotplot(ORA_setdiff_degs_naive)


cnetplot(ORA_intersect, foldChange = avg_FC,cex_label_gene = 0.5,cex_label_category = .8)
cnetplot(ORA_setdiff_degs_naive, foldChange = avg_FC_diff_naive)
cnetplot(ORA_setdiff_degs_conv, foldChange = avg_FC_diff_conv)

ggsave(paste0("../",result.dir,"network_intersect_genes.pdf"),
         width = 6,height = 4, dpi = 300)
```

## Pick specific genes for plotting

```{r plot_genes_of_interest}


rpkm_plot <- rpkm_filtered %>% 
  as.data.frame() %>%
  tibble::rownames_to_column("gene_symbol") %>%
  tidyr::pivot_longer(!gene_symbol, values_to = "RPKM") %>%
  dplyr::rename(ID_time_dose = name) %>%
  full_join(sampleTable, by = "ID_time_dose") %>%
  mutate(conditions = factor(conditions, 
                             levels = c("Neg_0_dose1", "Neg_24_dose1", 
                                        "Neg_0_dose2", "Neg_24_dose2", 
                                        "Pos_0_dose1", "Pos_24_dose1", 
                                        "Pos_0_dose2", "Pos_24_dose2"),
                             ordered = TRUE)) 


rpkm_plot %>%
  filter(grepl("^IL1RN|^IL1B|^IL1A|^IL1R1|^IL1A|^NOD|^CASP1$|^GSDMD|^NLR", gene_symbol))  %>%
  ggplot(aes(y = RPKM, x = dose, group = subject_ID, color = group)) +
  geom_point()+
  geom_line() +
  scale_y_log10() +
  cowplot::theme_cowplot()+
  ggsci::scale_color_npg() +
  labs(y = "Reads per kilo base per million (RPKM)", x = "") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_grid(~gene_symbol)


rpkm_plot %>%
  filter(grepl("^IL6|^TNF", gene_symbol))  %>%
  ggplot(aes(y = RPKM, x = conditions, group = subject_ID, color = group)) +
  geom_point()+
  geom_line() +
  scale_y_log10() +
  cowplot::theme_cowplot()+
  ggsci::scale_color_npg() +
  labs(y = "Reads per kilo base per million (RPKM)", x = "") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_grid(~gene_symbol)


```
## Fold-change from normalized data

```{r fold_change}
set.seed(140)
to_loop <- unique(sub( "_.*","",colnames(rpkm_filtered)))

df <- list()
for (column in to_loop){
  print(column)
  pattern_0_dose1 <- paste(column, "0_dose1",sep="_")
  pattern_24_dose1 <- paste(column, "24_dose1",sep="_")
  pattern_0_dose2 <- paste(column, "0_dose2",sep="_")
  pattern_24_dose2 <- paste(column, "24_dose2",sep="_")
  
  if(column == "222-21"){
     df[[column]] <- data.frame(genes = rownames(rpkm_filtered),
                                FC_dose1 = rpkm_filtered[,pattern_24_dose1]/rpkm_filtered[,pattern_0_dose1],
                                FC_dose2 = NA)
  }else{
     df[[column]] <- data.frame(genes = rownames(rpkm_filtered),
                                FC_dose1 = rpkm_filtered[,pattern_24_dose1]/rpkm_filtered[,pattern_0_dose1],
                                FC_dose2 = rpkm_filtered[,pattern_24_dose2]/rpkm_filtered[,pattern_0_dose2])
  }
}
  
fold_changes <- data.table::rbindlist(df, idcol = TRUE) %>%
  dplyr::rename(sample_ID = .id) %>%
  tidyr::pivot_wider(names_from = sample_ID,
                     values_from = c(FC_dose1,FC_dose2)) %>%
  as.data.frame()

fold_changes <- data.frame(fold_changes, row.names = 1) %>%
  select(-19) %>%
  as.matrix()
fold_changes <- log2(fold_changes)
fold_changes <- fold_changes[!is.infinite(rowSums(fold_changes)),]
fold_changes <- fold_changes[is.finite(rowSums(fold_changes)),]

metadata_2 <- sampleTable %>%
  mutate(heatmap_ID = paste0("FC", gsub("0|24","",dose),"_", gsub("-",".", subject_ID)),
         dose = gsub("0|24|_","",dose)) %>%
  select(heatmap_ID,group, dose) %>%
  distinct()
rownames(metadata_2) <- metadata_2$heatmap_ID

subset(fold_changes, rownames(fold_changes) %in% degs_names) %>%
  pheatmap(clustering_method = "complete",
         cutree_cols = 2,
          kmeans_k = 20,
           scale = "none", 
           show_rownames = FALSE,
           annotation_col = metadata_2[-1]) 
subset_fold_changes <- subset(fold_changes, rownames(fold_changes) %in% degs_names)

```

```{r plot_fold_change}
subset(fold_changes, grepl("^IL6",rownames(fold_changes))) %>%
  pheatmap(clustering_method = "complete",
           scale = "none", 
           show_rownames = TRUE,
           annotation_col = metadata_2[-1]) 

subset(fold_changes, grepl("^IL1RN|^IL1B|^IL1A|^IL1R1|^IL1A|^NOD|^CASP1$|^GSDMD|^NLR",rownames(fold_changes))) %>%
  pheatmap(clustering_method = "ward.D2",
           scale = "none", 
           show_rownames = TRUE,
           cluster_rows = F,
           annotation_col = metadata_2[-1]) 

```

```{r }
# Select best k number based on three different approaches

fviz_nbclust(subset_fold_changes, kmeans, k.max = 130 ,method = "silhouette", print.summary = TRUE) + theme(axis.text.x = element_text(angle = 90, size = 5, vjust = .5))
#fviz_nbclust(subset_fold_changes, kmeans, k.max = 130 ,method = "wss")
#gap_stat <- cluster::clusGap(subset_fold_changes, FUN = kmeans, nstart = 25, B = 50,
                    K.max = 130)
#fviz_gap_stat(gap_stat)
kmeans_groups <- kmeans(subset_fold_changes, centers = 57, iter.max = 1000)
fviz_cluster(kmeans_groups, geom = "point",data = subset_fold_changes)

# Subset 10-k
kmeans_groups <- kmeans(subset_fold_changes, centers = 20, iter.max = 1000)
fviz_cluster(kmeans_groups, geom = "point",data = subset_fold_changes)

# Join FC with antibody data

joint_ab_data <- t(kmeans_groups$centers) %>%
  as.data.frame() %>% 
  rownames_to_column("heatmap_ID") %>%
  left_join(metadata_2,by = "heatmap_ID") %>%
  mutate(sample_ID = gsub("\\.","-",gsub(".*_", "",heatmap_ID))) %>%
  left_join(antibody_data, by="sample_ID") %>%
  select(group, dose,BMI,as.character(seq(1:20)),Spike_W6,RBD_W6, Spike_W18, Spike_Avidity_W6, Spike_Avidity_W18)
  #select(group, dose,BMI,as.character(c(3,4,5,21,22,28,37,39,52)),Spike_W6,RBD_W6, Spike_W18, Spike_Avidity_W6, Spike_Avidity_W18)

correlation <- cor(joint_ab_data[-c(1,2)])

res1 <- corrplot::cor.mtest(joint_ab_data[-c(1,2)], conf.level = .95)
corrplot::corrplot(correlation, 
                   type="lower",
                   p.mat = res1$p,
                   insig = "label_sig",
                   sig.level = c(.001, .01, .05),
                   pch.cex = 0.8)

```

### Digging into the clusters that are correlated to antibody responses

```{r digging_clusters}

cluster4 <- names(kmeans_groups$cluster[kmeans_groups$cluster == 4])
cluster5 <- names(kmeans_groups$cluster[kmeans_groups$cluster == 5])
cluster7 <- names(kmeans_groups$cluster[kmeans_groups$cluster == 7])
cluster9 <- names(kmeans_groups$cluster[kmeans_groups$cluster == 8])
cluster9

fold_changes_df <- as.data.frame(fold_changes)
fold_changes_df[rownames(fold_changes_df) %in% cluster9,] %>%
  as.data.frame() %>%
  rownames_to_column("genes") %>%
  tidyr::pivot_longer(cols = c(everything(), -genes), names_to = "heatmap_ID", values_to = "FC_log10") %>%
  left_join(metadata_2,by = "heatmap_ID") %>%
  mutate(sample_ID = gsub("\\.","-",gsub(".*_", "",heatmap_ID))) %>%
  left_join(antibody_data, by="sample_ID") %>%
  ggplot(aes(x = FC_log10, y = RBD_W6)) +
  geom_point(aes(color = group)) +
  geom_smooth(method = "lm") +
  ggpubr::stat_cor(method = "pearson")+
  scale_y_log10() +
  facet_wrap(~genes)
```
### Second approach for selecting genes correlated to antibody data

## Correlation matrix values

After FDR correction, no genes are significantly correlated to antibody data using this approach. When not adjusting the p-value and reducing the p-value threshold, some genes appear to be correlated.

```{r correlation}
# Generate new metadata containing subject ID and group only
metadata_3 <- metadata_2 %>%
  mutate(subject_ID = gsub(".*_","",heatmap_ID)) %>%
  rownames_to_column("samples") %>%
  select(subject_ID, group) %>%
  distinct()
  
# Gather fold-change for dose 1
fold_changes_corr_1 <- fold_changes_df %>%
  as.data.frame() %>%
  rownames_to_column("genes") %>%
  tidyr::pivot_longer(cols = grep(pattern = "FC_dose1", x = colnames(fold_changes_df), value = TRUE), names_to = "heatmap_ID", values_to = "Log2FC_dose1") %>%
  mutate(subject_ID = gsub(".*_","",heatmap_ID)) %>%
  select(subject_ID, Log2FC_dose1, genes, heatmap_ID) %>%
  data.table::as.data.table()
# Gather fold-change for dose 2
fold_changes_corr_2 <- fold_changes_df %>%
  as.data.frame() %>%
  rownames_to_column("genes") %>%
  tidyr::pivot_longer(cols = grep(pattern = "FC_dose2", x = colnames(fold_changes_df), value = TRUE), names_to = "heatmap_ID", values_to = "Log2FC_dose2") %>%
  mutate(subject_ID = gsub(".*_","",heatmap_ID)) %>%
  select(subject_ID, Log2FC_dose2, genes, heatmap_ID) %>%
  data.table::as.data.table()

# Joing fold_change datasets and metadata
fold_changes_corr <- full_join(fold_changes_corr_1, fold_changes_corr_2, by = c("subject_ID", "genes")) %>%
  left_join(metadata_3,by = "subject_ID") %>%
  mutate(sample_ID = gsub("\\.", "-", subject_ID)) %>%
  left_join(antibody_data, by="sample_ID") %>%
  select(genes, group, sample_ID, Log2FC_dose2, Log2FC_dose1, sample_ID,Spike_W6,RBD_W6, Spike_W18, Spike_Avidity_W6, Spike_Avidity_W18) 

fold_changes_corr_wider <-  fold_changes_corr %>% tidyr::pivot_wider(values_from = Log2FC_dose1, names_from = genes) 

fold_changes_corr_test <- psych::corr.test(x = fold_changes_corr_wider[-c(1:8)], y = fold_changes_corr_wider[c(4:8)], adjust = "holm", ci = FALSE, method = "pearson")

sum(fold_changes_corr_test$p.adj < 0.05)
sum(fold_changes_corr_test$p < 0.0001)

fold_changes_corr_test <- merge(fold_changes_corr_test$p,fold_changes_corr_test$r, by = 0 )

corr_gene_names <- fold_changes_corr_test  %>%
  filter(Spike_W6.x < 0.05, Spike_W18.x < 0.05,Spike_Avidity_W6.x < 0.05, Spike_Avidity_W18.x < 0.05) %>%
  pull(Row.names)


#corr_gene_names <- fold_changes_corr_test  %>%
#  filter(Spike_W6.y < -.5, Spike_W6.y < -.5, Spike_Avidity_W6.y < -.5, Spike_Avidity_W18.y < -.5) %>%
#  pull(Row.names)
corr_gene_names <- fold_changes_corr_test  %>%
  filter(Spike_W6.y > .5, Spike_W6.y > .5, Spike_Avidity_W6.y > .5, Spike_Avidity_W18.y > .5) %>%
  pull(Row.names)


fold_changes_corr %>%
  filter(genes %in% corr_gene_names) %>%
  ggplot(aes(FC_log10, Spike_W18)) +
  geom_point(aes(color = group)) +
  scale_y_log10() +
  geom_smooth(method = "lm") +
  ggpubr::stat_cor(method = "pearson")+
  facet_wrap(~genes)

```

### Third approach for correlating antibody with enriched datasets

This approach is based on selecting the blood transcription modules that are enriched for all the datasets we have. Those are related to enrichment in monocytes (M11) and type I interferon response (M127)

```{r}
btm_modules <- readxl::read_xls("../data/blood_transcription_module/btm_annotation_table.xls") %>% filter(grepl(pattern = "M11.0|M127", x = ID))

M11_genes <- btm_modules %>% filter( ID == "M11.0") %>% pull(`Module member genes`) %>% str_split(",") %>% unlist()

M127_genes <- btm_modules %>% filter( ID == "M127") %>% pull(`Module member genes`) %>% str_split(",") %>% unlist()

fold_changes_df[M127_genes,] %>% t() %>%
  as.data.frame() %>%
  rownames_to_column("heatmap_ID") %>%
  left_join(metadata_2, by = "heatmap_ID") %>%
  mutate(sample_ID = gsub("\\.","-",gsub(".*_", "",heatmap_ID))) %>%
  left_join(antibody_data, by="sample_ID") %>%
  tidyr::pivot_longer(cols =  c("TAP1", "IFIH1","IRF7","PARP9", "STAT1", "PLSCR1","IFITM1","HERC5","DDX60","USP18","RSAD2", "IFIT1") , values_to = "FC_log2", names_to = "genes") %>%
ggplot(aes(x = FC_log2, y = Spike_W6)) +
  geom_point(aes(color = group)) +
  geom_smooth(method = "lm") +
  ggpubr::stat_cor(method = "spearman")+
  scale_y_log10() +
  facet_wrap(~genes + dose, ncol = 4)
  
corr_M127 <- fold_changes_df[M127_genes,] %>% t() %>%
  as.data.frame() %>%
  rownames_to_column("heatmap_ID") %>%
  left_join(metadata_2, by = "heatmap_ID") %>%
  mutate(sample_ID = gsub("\\.","-",gsub(".*_", "",heatmap_ID))) %>%
  left_join(antibody_data, by="sample_ID") %>%
  select(c(2:12,30,31,42,43))
  
correlation <- cor(corr_M127)
res1 <- corrplot::cor.mtest(corr_M127, conf.level = .95)
corrplot::corrplot(correlation, 
                   type="lower",
                   p.mat = res1$p,
                   insig = "label_sig",
                   sig.level = c(.001, .01, .05),
                   pch.cex = 0.8)


corr_M11 <- fold_changes_df[M11_genes,] %>% t() %>%
  as.data.frame() %>%
  rownames_to_column("heatmap_ID") %>%
  left_join(metadata_2, by = "heatmap_ID") %>%
  mutate(sample_ID = gsub("\\.","-",gsub(".*_", "",heatmap_ID))) %>%
  left_join(antibody_data, by="sample_ID") %>%
  select(c(2:190,7,8,218,219)) 
corr_M11[is.na(corr_M11)] <- 0
?cor.test
correlation <- cor(corr_M11)
res1 <- corrplot::cor.mtest(corr_M11, conf.level = .95)
View(res1$p < 0.05)
names(res1[res1$p < 0.05])
corrplot::corrplot(correlation, 
                   type="lower",
                   p.mat = res1$p,
                   insig = "label_sig",
                   sig.level = c(.001, .01, .05),
                   pch.cex = 0.8)

corr_M11 <- fold_changes_df[M11_genes,] %>% t() %>%
  as.data.frame() %>%
  rownames_to_column("heatmap_ID") %>%
  left_join(metadata_2, by = "heatmap_ID") %>%
  mutate(sample_ID = gsub("\\.","-",gsub(".*_", "",heatmap_ID))) %>%
  left_join(antibody_data, by="sample_ID") 
corr_M11[is.na(corr_M11)] <- 0  

corr_res <- corr_M11 %>%
  rstatix::cor_test(Spike_W6, method = "spearman")
```

## Machine learning

### Regularized linear regression
```{r linear_regression}
fold_changes_ab_data <- fold_changes_df %>%
  rownames_to_column("genes") %>%
  tidyr::pivot_longer(cols = c(everything(), -genes), names_to = "heatmap_ID", values_to = "FC_log10") %>%
  left_join(metadata_2,by = "heatmap_ID") %>%
  mutate(sample_ID = gsub("\\.","-",gsub(".*_", "",heatmap_ID))) %>%
  left_join(antibody_data, by="sample_ID") %>%
  select(sample_ID, dose, genes,FC_log10, Spike_Avidity_W6) %>%
  tidyr::pivot_wider(values_from = FC_log10, names_from = genes)


# Create training set and testing dataset
set.seed(140)
trainIndex <- createDataPartition(seq_len(nrow(fold_changes_ab_data)), p = .8,
                                  list = FALSE,
                                  times = 1)
trainingSet <- fold_changes_ab_data[ trainIndex,]
testingSet <- fold_changes_ab_data[-trainIndex,]

# Run model
cvfit <- glmnet::cv.glmnet(y=trainingSet[["Spike_Avidity_W6"]], x=as.matrix(trainingSet[-c(1:3)]), nfolds=16, parallel = TRUE, nlambda = 100, alpha = 1)

plot(cvfit)
lambda.opt <- 10
  
{fitB <- cvfit$glmnet.fit
plot(fitB, xvar="lambda")
abline(v=log(lambda.opt))}

coef(fitB, s=lambda.opt) 
rownames(coef(fitB, s=lambda.opt) )[coef(fitB, s=lambda.opt) [,1]!= 0]

predict(fitB, type="nonzero", s=lambda.opt)
assess.glmnet(fitB,
              newy=testingSet[["Spike_Avidity_W6"]], 
              newx=as.matrix(testingSet[-c(1:3)]))
glmnet::predict.glmnet(fitB, newx=as.matrix(testingSet[-c(1:3)]))

```

### Prepare data for machine learning algorithms

```{r}
#Continuing from Day 2 slide 25
#blind = FALSE, different from before, as true because you want to eliminate the biological differnce, which is optimal for QC
# set to false if you want to do clustering or classification analysis
# already done using vst function instead of rlog.
#Filter normalized counts

## harsh filtering for perform a analysis on your computer

#cofVar <- rowSds(fold_changes) / rowMeans(fold_changes)
#normCounts <- fold_changes[cofVar > quantile(cofVar, 0.7), ] 
#print(nrow(normCounts))

```

### Define caret functions

```{r}
#Define model fitting procedure
#NB: you will also need the packages statmod and e1071 for this analysis library(caret)
#New score function


rfSBF$score <- function(x, y){ 
  loadNamespace("pROC") 
  pROC::auc(pROC::multiclass.roc(y, x, quiet = TRUE))[1]
}
#New filter function
rfSBF$filter <- function(score, x, y){
top100 <- order(score, decreasing = TRUE)[1:10000] 
names(score) %in% names(score)[top100]
}

#using random forest
rfSBF$fit <- function(x, y,...){
randomForest::randomForest(x =x ,y=y, ntree = 1000) 
}
```

### Model fitting (C50 Decision tree)

Decision tree analysis using the `C50` package with Leave-one-out cross-validation (LOOCV).

```{r}

#Train and validate decision tree (C5.0)
levels_classification <- as.factor(cut(trainingSet[[3]], 5, labels=FALSE))
cut(trainingSet[[3]], 5)

#change for random forest here
dtControl <- sbfControl(functions = rfSBF, 
                         method = "loocv", 
                         saveDetails = TRUE, 
                         verbose = FALSE)

dtModel <- sbf(trainingSet[-c(1:3)], 
                levels_classification, 
                sbfControl = dtControl)
#Show model
summary(dtModel$fit)


{
varImp(dtModel$fit) %>%
    as.data.frame() %>%
  filter(Overall > 1) %>%
  mutate(Genes = row.names(.),
         variable=fct_reorder(Genes, Overall)) %>%
  ggplot(aes(x = Overall, y = variable)) +
    geom_point(size = 5, color = "black") +
  geom_segment( aes(y=variable, yend=variable, x=0, xend=Overall))+
  labs(x = "Overall variable importance (%)", y = "", title = "Variable importance: Decision tree model") +
    scale_x_continuous(expand = c(0,0)) +
  theme_bw()
}


```

### Model validation (C50 Decision tree)

```{r}
#function to plot confusion matrix
draw_confusion_matrix <- function(cm) {
  layout(matrix(c(1,1,2)))
  par(mar=c(2,2,2,2))
  plot(c(100, 345), c(300, 450), type = "n", xlab="", ylab="", xaxt='n', yaxt='n')
  title('CONFUSION MATRIX', cex.main=2)

  # create the matrix 
  rect(150, 430, 240, 370, col='#3F97D0')
  text(195, 435, 'Class1', cex=1.2)
  rect(250, 430, 340, 370, col='#F7AD50')
  text(295, 435, 'Class2', cex=1.2)
  text(125, 370, 'Predicted', cex=1.3, srt=90, font=2)
  text(245, 450, 'Actual', cex=1.3, font=2)
  rect(150, 305, 240, 365, col='#F7AD50')
  rect(250, 305, 340, 365, col='#3F97D0')
  text(140, 400, 'Class1', cex=1.2, srt=90)
  text(140, 335, 'Class2', cex=1.2, srt=90)

  # add in the cm results 
  res <- as.numeric(cm$table)
  text(195, 400, res[1], cex=1.6, font=2, col='white')
  text(195, 335, res[2], cex=1.6, font=2, col='white')
  text(295, 400, res[3], cex=1.6, font=2, col='white')
  text(295, 335, res[4], cex=1.6, font=2, col='white')

  # add in the specifics 
  plot(c(100, 0), c(100, 0), type = "n", xlab="", ylab="", main = "DETAILS", xaxt='n', yaxt='n')
  text(10, 85, names(cm$byClass[1]), cex=1.2, font=2)
  text(10, 70, round(as.numeric(cm$byClass[1]), 3), cex=1.2)
  text(30, 85, names(cm$byClass[2]), cex=1.2, font=2)
  text(30, 70, round(as.numeric(cm$byClass[2]), 3), cex=1.2)
  text(50, 85, names(cm$byClass[5]), cex=1.2, font=2)
  text(50, 70, round(as.numeric(cm$byClass[5]), 3), cex=1.2)
  text(70, 85, names(cm$byClass[6]), cex=1.2, font=2)
  text(70, 70, round(as.numeric(cm$byClass[6]), 3), cex=1.2)
  text(90, 85, names(cm$byClass[7]), cex=1.2, font=2)
  text(90, 70, round(as.numeric(cm$byClass[7]), 3), cex=1.2)

  # add in the accuracy information 
  text(30, 35, names(cm$overall[1]), cex=1.5, font=2)
  text(30, 20, round(as.numeric(cm$overall[1]), 3), cex=1.4)
  text(70, 35, names(cm$overall[2]), cex=1.5, font=2)
  text(70, 20, round(as.numeric(cm$overall[2]), 3), cex=1.4)
}  

cm <- confusionMatrix(dtModel$pred$predictions$pred, sampleTable$group)


 draw_confusion_matrix(cm)


```

### Model fitting (Random Forest)

Decision tree analysis using the `randomForest` package with Leave-one-out cross-validation (LOOCV).

```{r}
#Create training set
trainingSet <- data.frame(t(assay(normCounts)))
#Train and validate decision tree (C5.0)


#change for random forest here
dtControl <- sbfControl(functions = rfSBF, 
                         method = "loocv", 
                         saveDetails = TRUE, 
                         verbose = FALSE)

dtModel <- sbf(trainingSet, 
                sampleTable$group, 
                sbfControl = dtControl)
#Show model
summary(dtModel$fit)


{
randomForest::importance(dtModel$fit) %>%
    as.data.frame() %>%
 filter(MeanDecreaseGini > .6) %>%
  mutate(Genes = row.names(.),
         variable=fct_reorder(Genes, MeanDecreaseGini)) %>%
  ggplot(aes(x = MeanDecreaseGini, y = variable)) +
    geom_point(size = 5, color = "black") +
  geom_segment( aes(y=variable, yend=variable, x=0, xend=MeanDecreaseGini))+
  labs(x = "Mean Decrease Gini (variable importance)", y = "", title = "Variable importance: random forest model") +
    scale_x_continuous(expand = c(0,0)) +
  theme_bw()
}


```

### Plotting number of trees from random forest and estimated errors

```{r}
{

  plot(dtModel$fit, main = "Number of trees and error rates")

}
```

### Model validation (random forest)

```{r}
cm <- confusionMatrix(dtModel$pred$predictions$pred, sampleTable$group)

{

 draw_confusion_matrix(cm)

}
```

### Variable selection based on Machine Learning predictions

Based on the output of the decision tree and random forest, we have generated a generalized linear model based on the gene *BCL9L*.

```{r}

# transposing normalized counts
 tCounts <- data.frame(t(assay(counts_rlog_normalized)))

# processing data for logistic regression
tCounts <- tCounts %>% 
  select(c(TBC1D3L, ORM1, CCT6P3, KANK1,CAMP)) %>% 
  tibble::rownames_to_column() %>% 
  inner_join(sampleTable, by = c("rowname" = "sample_ID")) %>% 
  mutate(group_plot = if_else(group=="Pos", 1, 0))

# genelized linear model for logistic regression taking into account all gene of impotance by decision tree
#fit <- glm(group ~ BCL9L + MYO1B + GZMH + PCOLCE2 + BICDL1 + PCOLCE2 + FCER1A + CACNA2D2, data = tCounts, family = binomial) 

# genelized linear model for logistic regression taking into account the top 1 gene, BCL9L
fit <- glm(group ~ TBC1D3L, data = tCounts, family = binomial) 
summary(fit)

{
  plot(tCounts$TBC1D3L,tCounts$group_plot,
       col=tCounts$group,
       xlab="normalised counts",
       ylab="Probability",) 
  legend("bottomleft", legend = levels(tCounts$group),col=1:2,pch=1) 
  a <- coef(fit)[1] # Estimated  value of a 
  b <- coef(fit)[2] # Estimated  value of b 
  x <- seq(0,15,0.1)  # x-values for the curve 
  p <- 1 / (1+exp(-(a+b*x))) 
  lines(x,p,col="blue") 

}
```

### Session info

```{r}
sessionInfo()
```
