---
title: "Individual Report - Statistics in Bioinformatics"
author: "Rodrigo Arcoverde Cerveira"
date: '`r format(Sys.Date(), "%Y-%m-%d")`'
output: html_document
abstract: Individual report for the course of Statistics in Bioinformatics from the MedBioInfo graduate school.
knit: (function(inputFile, encoding) {
          rmarkdown::render(inputFile,
                            encoding = encoding, 
                            output_file = paste0(
                              xfun::sans_ext(inputFile), '_', Sys.Date(), '.html'),
                                output_dir = "../results/lab_book/")})
---

```{r global.options, include=FALSE}
#setting up figures and chunks messages

knitr::opts_knit$set(echo = TRUE,
                     root.dir = getwd(),
                     fig.width = 6, fig.height = 5,
                     fig.align = "center",
                     out.width = 768,
                     fig.pos = "H",
                     warning = FALSE, 
                     message = FALSE)
knitr::opts_chunk$set(warning = FALSE,
                      message = FALSE,
                      fig.width = 6, fig.height = 5,
                     fig.align = "center",
                     out.width = 768,
                     fig.pos = "H")

result.dir <- paste0("results/",Sys.Date(),"/")

## creates result.dir with date in if not existent
ifelse(isFALSE(dir.exists(paste0("../",result.dir))), dir.create(paste0("../",result.dir),recursive = TRUE),"Result directory for today exists already!")

options(stringsAsFactors = FALSE) 
```

## Loading libraries

```{r}
#Load libraries
#if you do not have libraries, they are located in either CRAN or Bioconductor
library(kableExtra)
library(forcats)
library(caret)
library(C50)
library(mgsub)
library(dplyr) 
library(DESeq2) 
library(pheatmap) 
library(ggplot2) 
library(ggrepel) 
library(RColorBrewer) 
library(limma) 
library(edgeR) 
library(enrichR) 
library(gridExtra) 
library(stringr)
library(ggVennDiagram)

```

## Download and load data

The dataset was extracted from the [**Overmyer et al., 2021**](https://doi.org/10.1016/j.cels.2020.10.003). The data can be download on the Geo Expression Omnibus (GEO) website under ascession number [**GSE157103**](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE157103). The metadata was extracted based on the samples file name, the names were saved as a **sample_metadata.tsv** file. For example, a file named "COVID_01_39y_male_NonICU" means patient ID 01, 39 years old, male sex, and not admitted to the Intensive Care Unit. 

```{r}

#reading data
countTable <- data.table::fread("../data/test_data/GSE157103_genes.ec.tsv", header = TRUE, sep = "\t") %>%
  as.data.frame()
rownames(countTable) <- countTable$"#symbol"
countTable <- countTable %>% select(-"#symbol") 

sampleTable <- read.table("../data/test_data/sample_metadata.tsv", as.is = TRUE, header = FALSE, sep = "\t") 

sampleTable <- data.frame(do.call("rbind", strsplit(as.character(sampleTable$V2), "_", fixed = TRUE)))
colnames(sampleTable)  <- c("sample_status","sample_number", "age","sex" , "ICUstat")

# processing data and removing data without complete metadata
sampleTable <- sampleTable %>%
  mutate(sample_number = sprintf("%01s", as.numeric(sampleTable$sample_number)),
    sample = ifelse(grepl("NONCOVID", sample_status,fixed = TRUE),
                         paste0("NC", sample_number),
                    paste0("C", sample_number)),
    age = as.numeric(gsub("y|:","",age)),
    sex = factor(sub("unknown","",sex)),
    ICUstat = factor(ICUstat),
    age_bin =  factor(ifelse(age > 50, "old", "young"))) %>% 
  filter(age != "", sex != "", sample_status == "COVID")

sampleTable$sex <- droplevels(sampleTable$sex)  
sampleTable$age_bin <- droplevels(sampleTable$age_bin)

#Inspect dataset dimensions
dim(countTable)
dim(sampleTable)

```

## Inspect data

Matching metadata to countTable and plotting the raw counts histogram for first visual inspection.  

```{r}
#Synchonize count data with sample table
countTable <- countTable[, pmatch(sampleTable$sample, colnames(countTable))]
colnames(countTable) <- sampleTable$sample

#Filter low counts
counts <- rowMeans(countTable)
hist(counts)
```

## Filtering data

Removing reads with the log2 of the counts per million (cpm) lower than 1.

```{r}

#Filter low counts
meanLog2CPM <- rowMeans(log2(cpm(countTable) + 1)) 
hist(meanLog2CPM)

countTable <- countTable[meanLog2CPM > 1, ] 

```

## DESeq object creation and data QC

Generating the DESeq dataset by rounding the values of the countTable, since the data is based on RNA-Seq by Expectation-Maximization (RSEM) algorithm. 

```{r}
# create DESeq object
dds <- DESeqDataSetFromMatrix(as.matrix(round(countTable)),
                              design = ~ 0 + sex + ICUstat,
                              colData = sampleTable)



#Normalize
normCounts <- vst(dds, blind = TRUE) 

#Distribution
hist(assay(normCounts))

#Sample heatmap
sampleDist <- cor(assay(dds), method = "spearman") 

Metadata <- data.frame(sampleTable$ICUstat, sampleTable$age, sampleTable$sex, sampleTable$age_bin)
names(Metadata) <- c("ICUstat","age", "sex", "age_bin")
Metadata$age <- as.numeric(Metadata$age)
rownames(Metadata) <- sampleTable$sample

```

```{r}

colors<-colorRampPalette(rev(brewer.pal(n=7,name="RdBu")))(255)

{
  pheatmap(sampleDist, color=colors, 
           clustering_distance_rows = as.dist(1 - sampleDist),
           clustering_distance_cols = as.dist(1 - sampleDist), 
           show_rownames = F,
           show_colnames = F,
           annotation_col = Metadata, cutree_cols = 6, cutree_rows = 6
  )
}


```


## Principal Component Analyais (PCA)

Dimensionality reduction for evaluating outliers and global sample clusters for both quality control but also for primary exploratory analysis.

```{r}

#Sample PCA
pcaRes <- prcomp(t(assay(normCounts)))
varExp <- round(pcaRes$sdev^2 / sum(pcaRes$sdev^2) * 100) 

pcaDF <- data.frame(
  PC1 = pcaRes$x[, 1],
  PC2 = pcaRes$x[, 2],
  ICUstat = sampleTable$ICUstat,
  Sample = sampleTable$sample)

pcaPlot <- ggplot( data = pcaDF, mapping = aes(x = PC1, y = PC2, color = ICUstat, label = Sample)) + geom_point(size = 3) +
  labs(x = paste0("PC1 (", varExp[1], " %)"), y = paste0("PC2 (", varExp[2], " %)")) + 
  theme_minimal() +
  theme(axis.text = element_text(size = 12), legend.text = element_text(size = 10)) +
  scale_color_manual(values = brewer.pal(3, "Accent")) 

print(pcaPlot)


```


## Statistical analysis and fitting a model

```{r}
#Step 1: Define design matrix
designMatrix <- model.matrix(~ 0 + ICUstat + sex, data = sampleTable) 
#designMatrix[1:5, 1:5]

#Step 2: Define contrast matrix
contrastMatrix <- makeContrasts(ICUstatICU - ICUstatNonICU , levels=make.names(colnames(designMatrix)))


#Step 3: Fit model
dge <- DGEList(countTable)
dge <- calcNormFactors(dge)
dge <- estimateDisp(dge, designMatrix, robust = TRUE) 
fit <- glmQLFit(dge, designMatrix, robust = TRUE)

#Step 4: Perform hypothesis testing
res <- glmQLFTest(fit, contrast = contrastMatrix)
res <- topTags(res, n = nrow(countTable))
sigRes <- subset(res$table, FDR < 0.05 & abs(logFC) > 1) 

kableExtra::kable(sigRes) %>%
  kableExtra::scroll_box(width = "100%", height = "100px")



```


## Visualization plot of DEG

Volcano plot for data exploranotory analysis, filtering for significant values with False Discovery Rate < 0.05 and log fold change greater than 1.

```{r}

#Visualize results
volcanoPlot <- ggplot(res$table, aes(x = logFC, y = -log10(FDR),
                                     color = ifelse(FDR < 0.05 & abs(logFC) > 1, "darkred", "grey"))) +
  geom_point() +
  xlab(expression("Fold Change (Log"[2]*")")) +
  ylab(expression("Adjusted P value (Log"[10]*")")) +
  geom_vline(xintercept = c(-1, 1), linetype = "dotted", size = 1) + 
  geom_hline(yintercept = -log10(0.05), linetype = "dotted", size = 1) + 
  theme_minimal() +
  theme(legend.position = "none") +
  scale_colour_manual(values = c("darkred", "grey", "steelblue")) + 
  geom_text_repel(aes(x = logFC, y = -log10(FDR), 
                      label = rownames(res$table)[1:10],
                      size = 2, color = "steelblue"),
                  data = res$table[1:10, ])
print(volcanoPlot)

```

## Enrichment analysis

Selecting two different databases for search for enrichment analysis. The databases selected were "GO_Biological_Process_2021" and "KEGG_2021_Human". Testing also the Blood Transcriptome modules presented in [Li et al. 2014](10.1038/ni.2789) using some GSEA package.

```{r}
#Enrichment analysis

enrichmentRes <- enrichr(
  genes = rownames(sigRes),
  databases = c("GO_Biological_Process_2021", "KEGG_2021_Human"))
```

## Visualize enriched pathways

```{r}

#Visualize significant terms
enrichPlots <- list()

for(res in names(enrichmentRes)){
  plotDF <- enrichmentRes[[res]][1:10, ]
  plotDF$Term = str_trunc(plotDF$Term, 45)
  plotDF$Term <- factor(plotDF$Term, levels = rev(plotDF$Term))
  
  enrichPlot <- ggplot(plotDF, aes(x = Term, y = -log10(Adjusted.P.value))) +
    geom_bar(stat = "identity", width = 0.05) + geom_point(size = 3) +
    theme_minimal() +
    theme(text = element_text(size = 10),
          plot.title = element_text(hjust = (5 / nchar(res)) * 2), 
          plot.margin = margin(t = 5, r = 50, b = 5, unit = "pt"), 
          axis.text.y = element_text(size = 8)) +
    coord_flip() +
    geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "gray") + 
    theme_bw() +
    labs(title = res, y = expression("Adjusted P value, Log"[10]*""))
  enrichPlots[[res]] <- enrichPlot 
  }

{
  plot(arrangeGrob(grobs = enrichPlots))
}
```


# Testing different variables interactions

## ICU stat, sex, age bin (> 50 vs< 50), and age_bin * sex.

```{r echo=FALSE}
designMatrix <- model.matrix(~ 0 + ICUstat + sex + age_bin + age_bin*sex, data = sampleTable) 
 
#Step 2: Define contrast matrix
contrastMatrix <- makeContrasts(ICUstatICU - ICUstatNonICU , levels=make.names(colnames(designMatrix)))


#Step 3: Fit model
dge <- DGEList(countTable)
dge <- calcNormFactors(dge)
dge <- estimateDisp(dge, designMatrix, robust = TRUE) 
fit <- glmQLFit(dge, designMatrix, robust = TRUE)

#Step 4: Perform hypothesis testing
res <- glmQLFTest(fit, contrast = contrastMatrix)
res <- topTags(res, n = nrow(countTable))
sigRes <- subset(res$table, FDR < 0.05 & abs(logFC) > 1) 

#Visualize results
volcanoPlot <- ggplot(res$table, aes(x = logFC, y = -log10(FDR),
                                     color = ifelse(FDR < 0.05 & abs(logFC) > 1, "darkred", "grey"))) +
  geom_point() +
  xlab(expression("Fold Change (Log"[2]*")")) +
  ylab(expression("Adjusted P value (Log"[10]*")")) +
  geom_vline(xintercept = c(-1, 1), linetype = "dotted", size = 1) + 
  geom_hline(yintercept = -log10(0.05), linetype = "dotted", size = 1) + 
  theme_minimal() +
  theme(legend.position = "none") +
  scale_colour_manual(values = c("darkred", "grey", "steelblue")) + 
  geom_text_repel(aes(x = logFC, y = -log10(FDR), 
                      label = rownames(res$table)[1:10],
                      size = 2, color = "steelblue"),
                  data = res$table[1:10, ])
print(volcanoPlot)
```

### Enrichment plot
```{r echo=FALSE}
#Visualize significant terms
enrichPlots <- list()

for(res in names(enrichmentRes)){
  plotDF <- enrichmentRes[[res]][1:10, ]
  plotDF$Term = str_trunc(plotDF$Term, 45)
  plotDF$Term <- factor(plotDF$Term, levels = rev(plotDF$Term))
  
  enrichPlot <- ggplot(plotDF, aes(x = Term, y = -log10(Adjusted.P.value))) +
    geom_bar(stat = "identity", width = 0.05) + geom_point(size = 3) +
    theme_minimal() +
    theme(text = element_text(size = 10),
          plot.title = element_text(hjust = (5 / nchar(res)) * 2), 
          plot.margin = margin(t = 5, r = 50, b = 5, unit = "pt"), 
          axis.text.y = element_text(size = 8)) +
    coord_flip() +
    geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "gray") + 
    theme_bw() +
    labs(title = res, y = expression("Adjusted P value, Log"[10]*""))
  enrichPlots[[res]] <- enrichPlot 
  }

{
  plot(arrangeGrob(grobs = enrichPlots))
}
```

## ICU status, sex, and age bin (> 50 vs< 50)

```{r echo=FALSE}
designMatrix <- model.matrix(~ 0 + ICUstat + sex + age_bin, data = sampleTable) 

#Step 2: Define contrast matrix
contrastMatrix <- makeContrasts(ICUstatICU - ICUstatNonICU , levels=make.names(colnames(designMatrix)))


#Step 3: Fit model
dge <- DGEList(countTable)
dge <- calcNormFactors(dge)
dge <- estimateDisp(dge, designMatrix, robust = TRUE) 
fit <- glmQLFit(dge, designMatrix, robust = TRUE)

#Step 4: Perform hypothesis testing
res <- glmQLFTest(fit, contrast = contrastMatrix)
res <- topTags(res, n = nrow(countTable))
sigRes <- subset(res$table, FDR < 0.05 & abs(logFC) > 1) 
#Visualize results
volcanoPlot <- ggplot(res$table, aes(x = logFC, y = -log10(FDR),
                                     color = ifelse(FDR < 0.05 & abs(logFC) > 1, "darkred", "grey"))) +
  geom_point() +
  xlab(expression("Fold Change (Log"[2]*")")) +
  ylab(expression("Adjusted P value (Log"[10]*")")) +
  geom_vline(xintercept = c(-1, 1), linetype = "dotted", size = 1) + 
  geom_hline(yintercept = -log10(0.05), linetype = "dotted", size = 1) + 
  theme_minimal() +
  theme(legend.position = "none") +
  scale_colour_manual(values = c("darkred", "grey", "steelblue")) + 
  geom_text_repel(aes(x = logFC, y = -log10(FDR), 
                      label = rownames(res$table)[1:10],
                      size = 2, color = "steelblue"),
                  data = res$table[1:10, ])
print(volcanoPlot)
```

### Enrichment plot
```{r echo=FALSE}
#Visualize significant terms
enrichPlots <- list()

for(res in names(enrichmentRes)){
  plotDF <- enrichmentRes[[res]][1:10, ]
  plotDF$Term = str_trunc(plotDF$Term, 45)
  plotDF$Term <- factor(plotDF$Term, levels = rev(plotDF$Term))
  
  enrichPlot <- ggplot(plotDF, aes(x = Term, y = -log10(Adjusted.P.value))) +
    geom_bar(stat = "identity", width = 0.05) + geom_point(size = 3) +
    theme_minimal() +
    theme(text = element_text(size = 10),
          plot.title = element_text(hjust = (5 / nchar(res)) * 2), 
          plot.margin = margin(t = 5, r = 50, b = 5, unit = "pt"), 
          axis.text.y = element_text(size = 8)) +
    coord_flip() +
    geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "gray") + 
    theme_bw() +
    labs(title = res, y = expression("Adjusted P value, Log"[10]*""))
  enrichPlots[[res]] <- enrichPlot 
  }

{
  plot(arrangeGrob(grobs = enrichPlots))
}
```

## ICU status and age bin (> 50 vs< 50)

```{r echo=FALSE}
designMatrix <- model.matrix(~ 0 + ICUstat + age_bin, data = sampleTable) 

#Step 2: Define contrast matrix
contrastMatrix <- makeContrasts(ICUstatICU - ICUstatNonICU , levels=make.names(colnames(designMatrix)))


#Step 3: Fit model
dge <- DGEList(countTable)
dge <- calcNormFactors(dge)
dge <- estimateDisp(dge, designMatrix, robust = TRUE) 
fit <- glmQLFit(dge, designMatrix, robust = TRUE)

#Step 4: Perform hypothesis testing
res <- glmQLFTest(fit, contrast = contrastMatrix)
res <- topTags(res, n = nrow(countTable))
sigRes <- subset(res$table, FDR < 0.05 & abs(logFC) > 1) 
#Visualize results
volcanoPlot <- ggplot(res$table, aes(x = logFC, y = -log10(FDR),
                                     color = ifelse(FDR < 0.05 & abs(logFC) > 1, "darkred", "grey"))) +
  geom_point() +
  xlab(expression("Fold Change (Log"[2]*")")) +
  ylab(expression("Adjusted P value (Log"[10]*")")) +
  geom_vline(xintercept = c(-1, 1), linetype = "dotted", size = 1) + 
  geom_hline(yintercept = -log10(0.05), linetype = "dotted", size = 1) + 
  theme_minimal() +
  theme(legend.position = "none") +
  scale_colour_manual(values = c("darkred", "grey", "steelblue")) + 
  geom_text_repel(aes(x = logFC, y = -log10(FDR), 
                      label = rownames(res$table)[1:10],
                      size = 2, color = "steelblue"),
                  data = res$table[1:10, ])
print(volcanoPlot)
```

### Enrichment plot
```{r echo=FALSE}
#Visualize significant terms
enrichPlots <- list()

for(res in names(enrichmentRes)){
  plotDF <- enrichmentRes[[res]][1:10, ]
  plotDF$Term = str_trunc(plotDF$Term, 45)
  plotDF$Term <- factor(plotDF$Term, levels = rev(plotDF$Term))
  
  enrichPlot <- ggplot(plotDF, aes(x = Term, y = -log10(Adjusted.P.value))) +
    geom_bar(stat = "identity", width = 0.05) + geom_point(size = 3) +
    theme_minimal() +
    theme(text = element_text(size = 10),
          plot.title = element_text(hjust = (5 / nchar(res)) * 2), 
          plot.margin = margin(t = 5, r = 50, b = 5, unit = "pt"), 
          axis.text.y = element_text(size = 8)) +
    coord_flip() +
    geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "gray") + 
    theme_bw() +
    labs(title = res, y = expression("Adjusted P value, Log"[10]*""))
  enrichPlots[[res]] <- enrichPlot 
  }

{
  plot(arrangeGrob(grobs = enrichPlots))
}
```

## Only ICU status

```{r echo=FALSE}
designMatrix_4 <- model.matrix(~ 0 + ICUstat, data = sampleTable)

#Step 2: Define contrast matrix
contrastMatrix <- makeContrasts(ICUstatICU - ICUstatNonICU , levels=make.names(colnames(designMatrix)))


#Step 3: Fit model
dge <- DGEList(countTable)
dge <- calcNormFactors(dge)
dge <- estimateDisp(dge, designMatrix, robust = TRUE) 
fit <- glmQLFit(dge, designMatrix, robust = TRUE)

#Step 4: Perform hypothesis testing
res <- glmQLFTest(fit, contrast = contrastMatrix)
res <- topTags(res, n = nrow(countTable))
sigRes <- subset(res$table, FDR < 0.05 & abs(logFC) > 1) 

#Visualize results
volcanoPlot <- ggplot(res$table, aes(x = logFC, y = -log10(FDR),
                                     color = ifelse(FDR < 0.05 & abs(logFC) > 1, "darkred", "grey"))) +
  geom_point() +
  xlab(expression("Fold Change (Log"[2]*")")) +
  ylab(expression("Adjusted P value (Log"[10]*")")) +
  geom_vline(xintercept = c(-1, 1), linetype = "dotted", size = 1) + 
  geom_hline(yintercept = -log10(0.05), linetype = "dotted", size = 1) + 
  theme_minimal() +
  theme(legend.position = "none") +
  scale_colour_manual(values = c("darkred", "grey", "steelblue")) + 
  geom_text_repel(aes(x = logFC, y = -log10(FDR), 
                      label = rownames(res$table)[1:10],
                      size = 2, color = "steelblue"),
                  data = res$table[1:10, ])
print(volcanoPlot)
```

### Enrichment plot
```{r echo=FALSE}
#Visualize significant terms
enrichPlots <- list()

for(res in names(enrichmentRes)){
  plotDF <- enrichmentRes[[res]][1:10, ]
  plotDF$Term = str_trunc(plotDF$Term, 45)
  plotDF$Term <- factor(plotDF$Term, levels = rev(plotDF$Term))
  
  enrichPlot <- ggplot(plotDF, aes(x = Term, y = -log10(Adjusted.P.value))) +
    geom_bar(stat = "identity", width = 0.05) + geom_point(size = 3) +
    theme_minimal() +
    theme(text = element_text(size = 10),
          plot.title = element_text(hjust = (5 / nchar(res)) * 2), 
          plot.margin = margin(t = 5, r = 50, b = 5, unit = "pt"), 
          axis.text.y = element_text(size = 8)) +
    coord_flip() +
    geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "gray") + 
    theme_bw() +
    labs(title = res, y = expression("Adjusted P value, Log"[10]*""))
  enrichPlots[[res]] <- enrichPlot 
  }

{
  plot(arrangeGrob(grobs = enrichPlots))
}
```

## Comparing Limma vs DESeq2

Comparing the output from Voom (limma) and DEseq2 with logFC> 1 and p<0.05

```{r Lets try Limma}
d0 <- DGEList(countTable)
d0 <- calcNormFactors(d0)
d <- d0 

snames <- colnames(countTable) # Sample names

ICUstat<-sampleTable$ICUstat
Sex<-sampleTable$sex
group<-interaction(ICUstat, Sex)

mm <- model.matrix(~ICUstat*Sex)
y <- voom(d, mm, plot = F)
fit <- lmFit(y, mm)
tmp <- contrasts.fit(fit, coef = 2) # Directly test second coefficient
tmp <- eBayes(tmp)
top.table <- topTable(tmp, sort.by = "logFC", n = Inf)

top.table <- top.table %>%
  filter(logFC > 1, adj.P.Val < 0.05)
```

## Venn diagram comparing DEGs found using Voom and DESeq2

```{r}
x<-list(rownames(top.table), rownames(sigRes))
ggVennDiagram(x, category.names=c("Voom", "DESeq2"))
```

# Prepare data for machine learning algorithms

```{r}
#Continuing from Day 2 slide 25
#blind = FALSE, different from before, as true because you want to eliminate the biological differnce, which is optimal for QC
# set to false if you want to do clustering or classification analysis
# already done using vst function instead of rlog.
#Filter normalized counts

## harsh filtering for perform a analysis on your computer
cofVar <- rowSds(assay(normCounts)) / rowMeans(assay(normCounts)) 
normCounts <- normCounts[cofVar > quantile(cofVar, 0.9), ] 
print(nrow(normCounts))

```

## Define caret functions

```{r}
#Define model fitting procedure
#NB: you will also need the packages statmod and e1071 for this analysis library(caret)
#New score function


rfSBF$score <- function(x, y){ 
  loadNamespace("pROC") 
  pROC::auc(pROC::roc(y, x, quiet = TRUE))[1]
}
#New filter function
rfSBF$filter <- function(score, x, y){
top100 <- order(score, decreasing = TRUE)[1:100] 
names(score) %in% names(score)[top100]
}

#Decision tree fit function
dtSBF <- rfSBF
dtSBF$fit <- function(x, y, ...){
C5.0(x = x, y = y) 
}

#using random forest
rfSBF$fit <- function(x, y,...){
randomForest::randomForest(x =x ,y=y, ntree = 3000) 
}
```

## Model fitting (C50 Decision tree)

Decision tree analysis using the ```C50``` package with Leave-one-out cross-validation (LOOCV).

```{r}

#Create training set
trainingSet <- data.frame(t(assay(normCounts)))
#Train and validate decision tree (C5.0)


#change for random forest here
dtControl <- sbfControl(functions = dtSBF, 
                         method = "loocv", 
                         saveDetails = TRUE, 
                         verbose = FALSE)

dtModel <- sbf(trainingSet, 
                sampleTable$ICUstat, 
                sbfControl = dtControl)
#Show model
summary(dtModel$fit)


{
varImp(dtModel$fit) %>%
    as.data.frame() %>%
  filter(Overall > 1) %>%
  mutate(Genes = row.names(.),
         variable=fct_reorder(Genes, Overall)) %>%
  ggplot(aes(x = Overall, y = variable)) +
    geom_point(size = 5, color = "black") +
  geom_segment( aes(y=variable, yend=variable, x=0, xend=Overall))+
  labs(x = "Overall variable importance (%)", y = "", title = "Variable importance: Decision tree model") +
    scale_x_continuous(expand = c(0,0)) +
  theme_bw()
}


```

## Model validation (C50 Decision tree)

```{r}
#function to plot confusion matrix
draw_confusion_matrix <- function(cm) {
  layout(matrix(c(1,1,2)))
  par(mar=c(2,2,2,2))
  plot(c(100, 345), c(300, 450), type = "n", xlab="", ylab="", xaxt='n', yaxt='n')
  title('CONFUSION MATRIX', cex.main=2)

  # create the matrix 
  rect(150, 430, 240, 370, col='#3F97D0')
  text(195, 435, 'Class1', cex=1.2)
  rect(250, 430, 340, 370, col='#F7AD50')
  text(295, 435, 'Class2', cex=1.2)
  text(125, 370, 'Predicted', cex=1.3, srt=90, font=2)
  text(245, 450, 'Actual', cex=1.3, font=2)
  rect(150, 305, 240, 365, col='#F7AD50')
  rect(250, 305, 340, 365, col='#3F97D0')
  text(140, 400, 'Class1', cex=1.2, srt=90)
  text(140, 335, 'Class2', cex=1.2, srt=90)

  # add in the cm results 
  res <- as.numeric(cm$table)
  text(195, 400, res[1], cex=1.6, font=2, col='white')
  text(195, 335, res[2], cex=1.6, font=2, col='white')
  text(295, 400, res[3], cex=1.6, font=2, col='white')
  text(295, 335, res[4], cex=1.6, font=2, col='white')

  # add in the specifics 
  plot(c(100, 0), c(100, 0), type = "n", xlab="", ylab="", main = "DETAILS", xaxt='n', yaxt='n')
  text(10, 85, names(cm$byClass[1]), cex=1.2, font=2)
  text(10, 70, round(as.numeric(cm$byClass[1]), 3), cex=1.2)
  text(30, 85, names(cm$byClass[2]), cex=1.2, font=2)
  text(30, 70, round(as.numeric(cm$byClass[2]), 3), cex=1.2)
  text(50, 85, names(cm$byClass[5]), cex=1.2, font=2)
  text(50, 70, round(as.numeric(cm$byClass[5]), 3), cex=1.2)
  text(70, 85, names(cm$byClass[6]), cex=1.2, font=2)
  text(70, 70, round(as.numeric(cm$byClass[6]), 3), cex=1.2)
  text(90, 85, names(cm$byClass[7]), cex=1.2, font=2)
  text(90, 70, round(as.numeric(cm$byClass[7]), 3), cex=1.2)

  # add in the accuracy information 
  text(30, 35, names(cm$overall[1]), cex=1.5, font=2)
  text(30, 20, round(as.numeric(cm$overall[1]), 3), cex=1.4)
  text(70, 35, names(cm$overall[2]), cex=1.5, font=2)
  text(70, 20, round(as.numeric(cm$overall[2]), 3), cex=1.4)
}  

cm <- confusionMatrix(dtModel$pred$predictions$pred, sampleTable$ICUstat)

{
 draw_confusion_matrix(cm)
}

```

## Model fitting (Random Forest)

Decision tree analysis using the ```randomForest``` package with Leave-one-out cross-validation (LOOCV).

```{r}
#Create training set
trainingSet <- data.frame(t(assay(normCounts)))
#Train and validate decision tree (C5.0)


#change for random forest here
dtControl <- sbfControl(functions = rfSBF, 
                         method = "loocv", 
                         saveDetails = TRUE, 
                         verbose = FALSE)

dtModel <- sbf(trainingSet, 
                sampleTable$ICUstat, 
                sbfControl = dtControl)
#Show model
summary(dtModel$fit)


{
randomForest::importance(dtModel$fit) %>%
    as.data.frame() %>%
  filter(MeanDecreaseGini > 1) %>%
  mutate(Genes = row.names(.),
         variable=fct_reorder(Genes, MeanDecreaseGini)) %>%
  ggplot(aes(x = MeanDecreaseGini, y = variable)) +
    geom_point(size = 5, color = "black") +
  geom_segment( aes(y=variable, yend=variable, x=0, xend=MeanDecreaseGini))+
  labs(x = "Mean Decrease Gini (variable importance)", y = "", title = "Variable importance: random forest model") +
    scale_x_continuous(expand = c(0,0)) +
  theme_bw()
}


```


## Plotting number of trees from random forest and estimated errors

```{r}
{

  plot(dtModel$fit, main = "Number of trees and error rates")

}
```

## Model validation (random forest)

```{r}
cm <- confusionMatrix(dtModel$pred$predictions$pred, sampleTable$ICUstat)

{

 draw_confusion_matrix(cm)

}
```


## Variable selection based on Machine Learning predictions

Based on the output of the decision tree and random forest, we have generated a generalized linear model based on the gene *BCL9L*. 

```{r}

# transposing normalized counts
 tCounts <- data.frame(t(assay(normCounts)))

# processing data for logistic regression
tCounts <- tCounts %>% 
  select(c(BCL9L, MYO1B, GZMH, PCOLCE2, BICDL1, PCOLCE2, FCER1A, CACNA2D2)) %>% 
  tibble::rownames_to_column() %>% 
  inner_join(sampleTable, by = c("rowname" = "sample")) %>% 
  mutate(group = if_else(ICUstat=="ICU", 1, 0))

# genelized linear model for logistic regression taking into account all gene of impotance by decision tree
#fit <- glm(group ~ BCL9L + MYO1B + GZMH + PCOLCE2 + BICDL1 + PCOLCE2 + FCER1A + CACNA2D2, data = tCounts, family = binomial) 

# genelized linear model for logistic regression taking into account the top 1 gene, BCL9L
fit <- glm(group ~ BCL9L, data = tCounts, family = binomial) 
summary(fit)

{
  plot(tCounts$BCL9L,tCounts$group,
       col=tCounts$ICUstat,
       xlab="normalised counts",
       ylab="Probability") 
# legend("topleft",levels(tCounts$group),col=1:2,pch=1) 
  a <- coef(fit)[1] # Estimated  value of a 
  b <- coef(fit)[2] # Estimated  value of b 
  x <- seq(0,15,0.1)  # x-values for the curve 
  p <- 1 / (1+exp(-(a+b*x))) 
  lines(x,p,col="blue") 

}
```


## Discussion

This study aimed to elucidate different paramount points regarding methodological and biological processes in a COVID-19 RNA-Seq dataset. First, we aimed to partially validate the results presented by the original study[1](https://doi.org/10.1016/j.cels.2020.10.003). Second, we wanted to compare the impact of different algorithms and methods in the final interpretation of the results. Lastly, we generated an original algorithm for prediction of admission to Intensive Care Unit (ICU) of COVID-19 infected individuals with approximately 80% accuracy.

We have successfully identified the gene patterns associated to ICU status. Using the principal component analysis (PCA), we have acknowledged separate clusters of 49 ICU not admitted and 40 ICU admitted individuals. A similar pattern can also be seen on the heatmap, where it can be found two different hierarchical clusters with an acceptable separation of non-ICU and ICU admitted. However, using all the genes and different variables in a single plot can hide the true differences between groups due to convulated information. 

For that reason, we have performed gene-enrichment analysis to narrow to the pathways differentially expressed genes (DEG) between ICU status. Interestingly, we have identified the same patterns presented by the original study[1](https://doi.org/10.1016/j.cels.2020.10.003). This includes many pathways related to neutrophil activation, degranulation, and hematopoetic cell lineage differentiation. The role of neutrophils and COVID-19 disease severity has been discussed to be fundamental for worst disease prognosis due to excessive inflammation[2](https://doi.org/10.3389/fimmu.2021.652470). Thus, our findings are similar what have been already proposed as neutrophil infiltration and activation being associated to increased disease severity, in our study showed by being admitted to ICU. 

To explore the influence of different methodologies and hyperparameters in our analysis, we have tested different combinations of methods. We have compared the impact of adding ICU status, sex, and age as potential cofounders to be normalized by DESeq2. Although the results would have slightly different number of DEGs (data not shown), the main outcomes and interpretations seen through the volcano and enrichment analysis plots were similar. It is important to mention that our results only show that this strong signal of neutrophils activation or highly DEGs, for example, are not influenced by these variables. Nevertheless, confounders should always be taken into account, specially in cases where there are known confounders, such as sex and COVID-19 disease severity[3](https://doi.org/10.1038/s41467-020-19741-6). 

In addition to that, we have also compared two different R packages for RNA-Seq analysis DESeq2[4](https://doi.org/10.1186/s13059-014-0550-8) and Limma[5](https://doi.org/10.1093/nar/gkv007). Knowing both package use different complex statistical methods, it was expected to have different results when analysing DEGs between these two methods. DESeq2 is based on a negative binomial distribution while Limma is based on a simple linear model, which was originally designed for microarray data and later on extended to RNA-Seq[6](https://doi.org/10.1371/journal.pone.0190152). Approximately, only 25% of DEGs were found using both methologies, with DESeq2 discovering more DEGs than Voom (Limma package).It should be noted that we used the linear model present withing Limma package, which is technically incorrect according to the package maintainers that recommend normalizing data using EdgeR package[7](https://doi.org/10.18129/B9.bioc.edgeR). Thus, showing the importance of using the best and most updated version of packages for analysis can directly change your perception of your data.

Furthermore, we have successfully generated a prediction algorithm of ICU admission status with 80% accuracy based on the most variable genes. The RNA-Seq was performed during hospital admission, prior knowing the severity of the individual later on. Although, having the days of onset of symptoms would be optimal to categorize more efficiently the disease progression, we have shown that gene expression can predict ICU status in COVID-19 individuals. Our approach was based on two different machine learning methods, a simple decision tree and a random forest, both being validated by the Leave-One-Out Cross-Validation (LOOCV) method. A single decision tree had a accuracy of ~80% while the random forest had a accuracy of ~82%. Interestingly, a gene called *BCL9L* gene was found as an important feature for predicting ICU status in both machine learning methods. *BCL9L* is a transcriptional regulator mainly associated to tumorigenesis[8](https://doi.org/10.3892/ijmm.2018.3689) and so far without any described role for infectious diseases. Using this single gene, we were able to classify the ICU status of the majority of patients, as seen in the logistic regression model. 

Finally, we have reproduced the results generated by [Overmyer et al., 2021](https://doi.org/10.1016/j.cels.2020.10.003), an important learning task that shows how reliable a scientific analysis can be when properly shared. We have showed that the different cofounders for normalization of gene counts did not influence the main interpretation of the dataset. A different algorithm can generate a major difference in number of DEGs, during analysis or data interpretation one should not mix or directly compare results from Limma and DESeq2. Lastly, prediction of ICU status at the time of hospital admission is possible with high accuracy, a single gene can already provide a fair information regarding the admission to ICU which could be potently used in clinics.

### References

[1. Overmyer et al., 2021](https://doi.org/10.1016/j.cels.2020.10.003)    

[2. Reusch et al., 2021](https://doi.org/10.3389/fimmu.2021.652470)    

[3. Peckham et al., 2021](https://doi.org/10.1038/s41467-020-19741-6)    

[4. Love MI, Huber W, Anders S, 2014)](https://doi.org/10.1186/s13059-014-0550-8)   

[5. Ritchie et al., 2015](https://doi.org/10.1093/nar/gkv007)    

[6. Costa-Silva et al., 2017](https://doi.org/10.1371/journal.pone.0190152)  

[7. Robinson MD, McCarthy DJ, Smyth GK., 2010](https://doi.org/10.18129/B9.bioc.edgeR)   

[8. Masaru Katoh, 2018](https://doi.org/10.3892/ijmm.2018.3689)   





## Session info

```{r}
sessionInfo()
```